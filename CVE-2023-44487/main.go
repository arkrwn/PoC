package main

import (
	"bufio"
	"crypto/tls"
	"encoding/csv"
	"flag"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"time"

	"golang.org/x/net/http2"
)

// getExternalIP retrieves the external IP of the machine
func getExternalIP() (string, error) {
	resp, err := http.Get("http://ifconfig.me")
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	return string(body), nil
}

// getInternalIP retrieves the internal IP of the machine
func getInternalIP() (string, error) {
	conn, err := net.Dial("udp", "8.8.8.8:80")
	if err != nil {
		return "", err
	}
	defer conn.Close()

	localAddr := conn.LocalAddr().(*net.UDPAddr)

	return localAddr.IP.String(), nil
}

// checkHTTP2Support checks if the given URL supports HTTP/2
func checkHTTP2Support(url string) (bool, string, error) {
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	http2.ConfigureTransport(tr)
	client := &http.Client{Transport: tr}
	resp, err := client.Get(url)
	if err != nil {
		return false, "", err
	}
	defer resp.Body.Close()
	if resp.ProtoMajor == 2 && resp.ProtoMinor == 0 {
		return true, "", nil
	}
	return false, resp.Proto, nil
}

// sendRSTStream sends an RST_STREAM frame to the given host and port
func sendRSTStream(url string) (int, string) {
	// Implement the sendRSTStream functionality
	// This function may require a custom implementation as Go's standard library
	// does not expose a direct way to manipulate HTTP/2 frames
	return -1, "Not implemented"
}

func main() {
	inputFile := flag.String("input", "", "Input file containing URLs (Required)")
	outputFile := flag.String("output", "/dev/stdout", "Output CSV file")
	verbose := flag.Bool("verbose", false, "Verbose output")
	flag.Parse()

	if *inputFile == "" {
		flag.PrintDefaults()
		os.Exit(1)
	}

	internalIP, err := getInternalIP()
	if err != nil {
		fmt.Println("Error getting internal IP:", err)
		os.Exit(1)
	}

	externalIP, err := getExternalIP()
	if err != nil {
		fmt.Println("Error getting external IP:", err)
		os.Exit(1)
	}

	infile, err := os.Open(*inputFile)
	if err != nil {
		fmt.Println("Error opening input file:", err)
		os.Exit(1)
	}
	defer infile.Close()

	outfile, err := os.Create(*outputFile)
	if err != nil {
		fmt.Println("Error creating output file:", err)
		os.Exit(1)
	}
	defer outfile.Close()

	csvWriter := csv.NewWriter(outfile)
	defer csvWriter.Flush()

	csvWriter.Write([]string{"Timestamp", "Source Internal IP", "Source External IP", "URL", "Vulnerability Status", "Error/Downgrade Version"})

	scanner := bufio.NewScanner(infile)
	for scanner.Scan() {
		url := scanner.Text()
		if *verbose {
			fmt.Println("Checking", url)
		}
		http2Support, version, err := checkHTTP2Support(url)
		if err != nil {
			fmt.Println("Error checking HTTP/2 support:", err)
			continue
		}
		now := time.Now().Format("2006-01-02 15:04:05")
		if http2Support {
			status, errStr := sendRSTStream(url)
			switch status {
			case 1:
				csvWriter.Write([]string{now, internalIP, externalIP, url, "VULNERABLE", ""})
			case -1:
				csvWriter.Write([]string{now, internalIP, externalIP, url, "POSSIBLE", fmt.Sprintf("Failed to send RST_STREAM: %s", errStr)})
			case 0:
				csvWriter.Write([]string{now, internalIP, externalIP, url, "LIKELY", "Got empty response to RST_STREAM request"})
			}
		} else {
			csvWriter.Write([]string{now, internalIP, externalIP, url, "SAFE", fmt.Sprintf("Downgraded to %s", version)})
		}
	}
	if err := scanner.Err(); err != nil {
		fmt.Println("Error reading input file:", err)
	}
}
